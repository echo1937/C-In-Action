# 二十三、指针

## 22.1 指针的基本概念

- &是取地址运算符（Address Operator），&i表示取变量i的地址
    - &运算符的操作数必须是左值，运算结果是指针类型；
        - 如果表达式E可以做左值，*&E和E等价
- *是指针间接寻址运算符（Indirection Operator），*pi表示取指针pi所指向的变量的值
    - *运算符的操作数必须是指针类型，运算结果可以做左值；
        - 如果表达式E是指针类型，&*E和E等价
    - 指针有时候称为变量的引用（Reference），所以根据指针找到变量称为Dereference

      ```c
      int *p, *q;  // 整型指针p和q
      int *p, q    // 整型指针p和整型变量q
      ```

- 补充
    - *号在声明中表示声明一个指针类型，用在表达式中是间接寻址运算符
        - []括号在声明中表示声明一个数组，用在表达式中是取下标运算符
    - 野指针
      ```c
      /*
       * 举例: 定义一个指针类型的局部变量而没有初始化
       * 
       * 栈上分配的变量初始值是不确定的，也就是说指针p所指向的内存地址是不确定的，
       * 像这种指向不确定地址的指针称为“野指针”（Unbound Pointer）
       */
  
      int main(void) {
          int *p;    // int *p = NULL或者明确地给它赋值
          ...
          *p = 0;
          ...
      }
      ```
    - 空指针
      ```c
      /*
       * 指针也是一种标量类型, 可以用()运算符做强制类型转换, 其他标量类型和指针类型互相转换,
       * 比如把整型的0强制转换成void *指针, 这个指针指向0地址, 称为空指针
       * 
       * 操作系统不会把任何数据保存在地址0及其附近，也不会把地址0~0xfff的页面映射到物理内存，
       * 所以任何对地址0的访问都会立刻导致段错误。
       */
      #define NULL ((viod *)0)
      
      int main(void) {
          int *p = NULL;
          ...
          *p = 0;
          ...
      }
      ```
    - void *类型
        - ANSI在将C语言标准化时引入了void *类型，void *指针与其它类型的指针之间可以隐式转换，而不必用类型转换运算符。
            - 注意，只能定义void *指针，而不能定义void型的变量，因为void *
              指针和别的指针一样都占4个字节，而如果定义void型变量（也就是类型暂时不确定的变量），编译器不知道该分配几个字节给变量。同样道理，void *
              指针不能直接Dereference，而必须先转换成别的类型的指针再做Dereference。
      ```c
      /*
       * void *指针常用于函数接口，比如： 
       */
      void func(void *pv) {
          /* *pv = 'A' is illegal */
          char *pchar = pv;
          *pchar = 'A';
      }
  
      int main(void) {
          char c;
          func(&c);
          printf("%c\n", c);
          ...
      }
      ```

## 22.2 指针类型的参数和返回值

## 22.3 指针和数组

```c
int a[10]; 
int *pa = &a[0];  // 等价于 int *pa = a
pa++;
```

- E1[E2]这种写法和(\*((E1)+(E2)))是等价的，\*(pa+2)也可以写成pa[2]，pa就像数组名一样，a[2]之所以能取数组的第2个元素，是因为它等价于*(a+2)。
    - 由于(\*((E1)+(E2)))显然可以写成(*((E2)+(E1)))，所以E1[E2]也可以写成E2[E1]，这意味着2[a]、2[pa]这种写法也是对的，但一般不这么写
- 数组名做右值时自动转换成指向**首元素的指针**，所以a[2]和pa[2]本质上是一样的，都是通过指针间接寻址访问元素。
    - 由于a做右值使用时和&a[0]是一个意思，所以int *pa = &a[0];通常不这么写，而是写成更简洁的形式int *pa = a;
- 指向同一个数组中元素的指针之间相减才有意义, 相减的结果是 ptrdiff_t类型, 这个类型在stddef.h中定义
  - C语言规定两个指针不能相加
- 数据类型做右值时和指针的语法是统一的, 但如果把数组类型做左值使用, 和指针有区别
  - ++pa合法, ++a不合法; pa = a + 1合法, a = pa + 1不合法
    - 数组类型做左值时表示整个数组的存储空间, ++a(相当于a+=1), +=两边的操作数类型不符, a=pa+1左右两边类型不符

## 22.4 指针和const限定符

---|const int型的指针|int型的const指针|const int型的const指针
---|---|---|---
定义|const int *a 或者 int const *a;|int * const a;|int const * const a;
 *a|*a不允许改写|*a可以改写的|*a不允许改写
  a| a可以改写 |a不允许改写|a不允许改写

- 补充
  - 想要把指针p赋给指针q， q指向的类型应该比p指向的类型更严格，或至少是同样严格，而不能比p指向的类型限定得更宽松（左值更严格）

## 22.5 指针与结构体

- (*p).c和(*p).num可以写成p->c和p->num

## 22.6 指向指针的指针与指针数组

```c
// 函数原型中的[]表示指针而不表示数组，等价于char **argv
// 这样写给读代码的人提供了有用信息: argv不是指向单个指针，而是指向一个指针数组的首元素。数组中每个元素都是char *指针，指向一个命令行参数字符串。
#include <stdio.h>

int main(int argc, char *argv[]) {
    for(int i = 0; i < argc; i++) printf("argv[%d]=%s\n", i, argv[i]);
    return 0;
}
```

## 22.7 指向数组的指针与多维数组

```c
char *p[2]
// []的优先级比*更高，因此p先和[]结合，所以这个是一个数组，
// *用来修饰数组的，代表数组中的元素都是指针

char (*p)[2]
// 加了括号之后，p首先是一个指针，所以是数组指针
// 指向的是一个具有两个元素的数组
```

a是一个数组, &a[0]表示数组a的首元素的首地址, 而&a表示数组a的首地址, 虽然它们数值相同, 但这两个表达式的类型是两种不同的指针类型, 前者是int \*, 后者是int (*)[10]

```c
int a[10];
int (*pa)[10] = &a;
```